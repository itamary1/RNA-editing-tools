###DESCRIPTION: CREATES STACKED BARPLOT FOR ALIGNMENT STATISTICS
#VER 1 14.10.18: for STAR_stats.csv output

### SETUP -------------------------------------------------------------------

library(argparse)

# create parser object
parser <- ArgumentParser(description='Plot STAR alignment statistics to allow for visual analysis.')

# specify our desired options 
# by default ArgumentParser will add an help option 
parser$add_argument("-i", action="store", dest = "infile", help="Input file, STAR_stats.csv format (generated by STARstatsV2.py)")
parser$add_argument("-o", action="store", dest = "outdir",  help="Output directory path")
parser$add_argument("-l", action="store", dest = "logPath", default = "log.txt",  help="Path of log file (appends)")
parser$add_argument("-g", action="store", dest = "groupfile",  help="Divide graphs to facets by given groups. File should contain two columns: sample then group, tab delimited", default=NULL)
parser$add_argument("-p", action="store", dest = "prefix", default = NULL, help="Prefix for file names")
parser$add_argument("-a", action="store_true", dest = "all_graphs", default = FALSE, help="Create all statistics graphs (not just read mapping distribution)")

# get command line options, if help option encountered print help and exit,
# otherwise if options not found on command line then set defaults, 
user_args <- parser$parse_args()

# direct output to a file 
sink(file = user_args$logPath, append=TRUE)

print(paste0("infile: ", user_args$infile))
print(paste0("outdir: ", user_args$outdir))
print(paste0("logPath: ", user_args$logPath))
print(paste0("groupfile: ", user_args$groupfile))
print(paste0("prefix: ", user_args$prefix))
print(paste0("all_graphs: ", user_args$all_graphs))
### LOAD DATA -------------------------------------------------------------------

#load stats
stats <- read.csv(user_args$infile, header = T,stringsAsFactors = F,check.names = F, quote = "", na.strings = "NA") 

#load group file, if there is such
if (!is.null(user_args$groupfile)) {
  groups <- read.delim(user_args$groupfile, header = T,stringsAsFactors = F,check.names = F, quote = "", na.strings = "NA") 
  colnames(groups) <- c("Sample", "Group")
  stats <- merge(stats, groups)
} else {
  stats$Group <- "Samples"
}

if (is.null(user_args$prefix)) {
  user_args$prefix <- ""
} else {
  user_args$prefix <- paste0(user_args$prefix, "_")
}

print(paste("loaded data, Current prefix:", user_args$prefix, "\n"))


### Create outdir -----------------------------------------------------------
# if needed
if (!dir.exists(user_args$outdir)) { dir.create(user_args$outdir, recursive = T) }

### Preprocessing -----------------------------------------------------------

# > Percentage ----
toPlot <- stats[, c("Sample", "Group", "Uniquely mapped reads %")]
toPlot$Component <- "Mapped Properly"
colnames(toPlot) <- c("Sample", "Group", "Value", "Component")

addStat <- function(originalTable, addToTable, wantedCol, componentName) {
  temp <- originalTable[, wantedCol]
  temp$Component <- componentName
  colnames(temp) <- c("Sample", "Group", "Value", "Component")
  return(rbind(addToTable, temp))
}

toPlot <- addStat(stats, toPlot, c("Sample", "Group", "% of reads mapped to too many loci"), "Mapped To Multiple Loci")
toPlot <- addStat(stats, toPlot, c("Sample", "Group", "% of reads unmapped: too many mismatches"), "Unmapped: Too Many Mismatches")
toPlot <- addStat(stats, toPlot, c("Sample", "Group", "% of reads unmapped: too short"), "Unmapped: Alignment Too Short")
toPlot <- addStat(stats, toPlot, c("Sample", "Group", "% of reads unmapped: other"), "Unmapped: Other Reasons")


# > Read num ----
toPlotReaNum <- stats[, c("Sample", "Group", "Number of input reads", "Uniquely mapped reads number", "Number of reads mapped to too many loci")]
toPlotReaNum$"Unmapped Reads" <- toPlotReaNum$`Number of input reads` - toPlotReaNum$`Uniquely mapped reads number` - toPlotReaNum$`Number of reads mapped to too many loci`

library(reshape2)
toPlotReaNum <- melt(data = toPlotReaNum, id.vars = c("Sample", "Group"), measure.vars = c("Uniquely mapped reads number","Number of reads mapped to too many loci","Unmapped Reads"), variable.name = "Component", value.name = "ReadNum")
toPlotReaNum$Component <- gsub("Number of r", replacement = "R", toPlotReaNum$Component)
toPlotReaNum$Component <- gsub(" number", replacement = "", toPlotReaNum$Component)
toPlotReaNum$Component <- factor(toPlotReaNum$Component, levels = c("Uniquely mapped reads","Reads mapped to too many loci","Unmapped Reads"), ordered = T)


### PLOT --------------------------------------------------------------------
library(ggplot2)

chosen_colors = c("#009302", "#efac2f", "#c61000", "yellow", "cornsilk") #by ABC ordering of Tissue categories
chosen_colors2 = c("#009302", "#efac2f", "#c61000") #by ABC ordering of Tissue categories


# barplot -----------------------------------------------------------------

#function for easy and quick plotting of barplot
#colors vector should be in ABC order of categories, order is the wanted categories order
barplot=ggplot(toPlot, aes(x=Sample, y=Value, fill=Component, label = Value)) +
  geom_bar(stat="identity") +
  labs(x="Sample", y="Input Reads %") +
  ggtitle("Input Reads Distribution Per Sample") +
  scale_fill_manual(values=chosen_colors) +
  theme_light() + 
  theme(axis.text=element_text(size=10,colour = "black"),
        axis.text.x = element_blank(),
        legend.text =element_text( "",size=7),
        #legend.justification=c(1,1),
        #panel.grid.major = element_blank(),
        #panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5),
        axis.ticks = element_blank(),
        legend.position = "bottom", 
        legend.title = element_blank())

#if groups are given - split into facets by groups
if (!is.null(user_args$groupfile)) {
  barplot <- barplot + facet_grid(. ~ Group, scales = "free")
}

ggsave(barplot, filename =  file.path(user_args$outdir,paste0(user_args$prefix, "ReadMappingDistribution.pdf")), width = 10, height = 8, device = "pdf")
ggsave(barplot + geom_text(size = 3, position = position_stack(vjust = 0.5)) + theme(axis.text.x = element_text(size=10,colour = "black", angle = 90, hjust = 0.95)), filename = file.path(user_args$outdir,paste0(user_args$prefix, "ReadMappingDistribution.labels.pdf")), width = 10, height = 8, device = "pdf")


barplot=ggplot(toPlotReaNum, aes(x=Sample, y=ReadNum, fill=Component, label = ReadNum)) +
  geom_bar(stat="identity") +
  labs(x="Sample", y="Input Reads #") +
  ggtitle("Input Reads Distribution Per Sample") +
  scale_fill_manual(values=chosen_colors) +
  theme_light() + 
  theme(axis.text=element_text(size=10,colour = "black"),
        axis.text.x = element_blank(),
        legend.text =element_text( "",size=7),
        #legend.justification=c(1,1),
        #panel.grid.major = element_blank(),
        #panel.grid.minor = element_blank(),
        plot.title = element_text(hjust = 0.5),
        axis.ticks = element_blank(),
        legend.position = "bottom", 
        legend.title = element_blank())

#if groups are given - split into facets by groups
if (!is.null(user_args$groupfile)) {
  barplot <- barplot + facet_grid(. ~ Group, scales = "free")
}

ggsave(barplot, filename =  file.path(user_args$outdir,paste0(user_args$prefix, "MappedReadsNumber.pdf")), width = 10, height = 8, device = "pdf")
ggsave(barplot + geom_text(size = 2, position = position_stack(vjust = 0.5), angle=90) + theme(axis.text.x = element_text(size=10,colour = "black", angle = 90, hjust = 0.95)), filename = file.path(user_args$outdir,paste0(user_args$prefix, "MappedReadsNumber.labels.pdf")), width = 10, height = 8, device = "pdf")


print("plots saved\n")


# boxplots ----------------------------------------------------------------

#function for easy and quick plotting for boxplots, if needed (-a invoked)
#colors vector should be in ABC order of categories, order is the wanted categories order
boxPlot <- function(table, title, ylab, ylimit) {
  g=ggplot(table, aes(x = Group, y = Value)) + 
    geom_boxplot(aes(fill = Group),outlier.shape = NA) + 
    geom_jitter(position = position_jitter(width = .1), size = 0.5) +
    ylab(ylab) + 
    xlab("Group") + 
    ggtitle(title) +
    ylim(ylimit) +
    theme_classic() + 
    theme(axis.text=element_text(size=10,colour = "black", angle = 45, hjust = 1),
          #panel.background = element_rect(fill='white', colour='black'),
          legend.text =element_text( "",size=7),
          legend.justification=c(1,1),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold"),
          axis.ticks = element_line(colour="black"),
          legend.position = "none")
  
  return(g)
}

#plot alignment quality
box1 <- boxPlot(table = toPlot[toPlot$Component=="Mapped Properly", ], title = "Alignment Quality", ylab = "% Uniquely Mapped Reads", ylimit = c(0, 100))
#ggsave(box1, filename = file.path(user_args$outdir,paste0(user_args$prefix, "AlignmentQuality.pdf")), width = 10, height = 8, device = "pdf")

#plot input reads number
temp <- stats[, c("Sample", "Group", "Uniquely mapped reads number")]
colnames(temp) <- c("Sample", "Group", "Value")
box2 <- boxPlot(table = temp, title = "Uniquely Mapped Reads Number", ylab = "# Of Uniquely Mapped Reads", ylimit = c(min(temp$Value)-100, max(temp$Value)+100))
#ggsave(box2, filename = file.path(user_args$outdir,paste0(user_args$prefix, "UniquelyMappedReadsNumber.pdf")), width = 10, height = 8, device = "pdf")

#combine all graphs
library(cowplot) #first use - call cowplot
plotStats <- plot_grid(box1, box2, labels=c("", ""), ncol = 2, nrow = 1, align = 'v', hjust=-1, vjust = 1.5, label_size=14)
save_plot(filename = file.path(user_args$outdir,paste0(user_args$prefix, "CombinedStats.pdf")), plotStats, ncol = 2, nrow = 1, base_aspect_ratio = 1 )
#add labels and combine
plotStats2 <- plot_grid(box1 + stat_summary(fun.y = mean, geom="text",colour="black", size=4, aes(label=round(..y.., digits=1)), vjust=2.5),
                       box2+ stat_summary(fun.y = mean, geom="text",colour="black", size=4, aes(label=round(..y.., digits=1)), vjust=2.5), 
                       labels=c("", ""), ncol = 2, nrow = 1, align = 'v', hjust=-1, vjust = 1.5, label_size=14)
save_plot(filename = file.path(user_args$outdir,paste0(user_args$prefix, "CombinedStats.labels.pdf")), plotStats2, ncol = 2, nrow = 1, base_aspect_ratio = 1 )


if (user_args$all_graphs) {
  print("Generating extra plots...\n")
  
  #plot other measures
  lim = c(0, NA)
  box <- list()
  box[[1]] <- boxPlot(table = toPlot[toPlot$Component=="Mapped To Multiple Loci", ], title = "Reads Mapped To Multiple Loci", ylab = "% Reads Mapped To Too Many Loci", ylimit = lim)
  box[[2]] <- boxPlot(table = toPlot[toPlot$Component=="Unmapped: Too Many Mismatches", ], title = "Reads Unmapped: Too Many Mismatches", ylab = "% Reads Unmapped: Too Many Mismatches", ylimit = lim)
  box[[3]] <- boxPlot(table = toPlot[toPlot$Component=="Unmapped: Alignment Too Short", ], title = "Reads Unmapped: Alignment Seed Too Short", ylab = "% Reads Unmapped: Alignment Too Short", ylimit = lim)
  box[[4]] <- boxPlot(table = toPlot[toPlot$Component=="Unmapped: Other Reasons", ], title = "Reads Unmapped Due To Other Reasons", ylab = "% Reads Unmapped: Other Reasons", ylimit = lim)
  
  
  #combine all graphs
  plotExtraStats <- plot_grid(box[[1]] + xlab(""), box[[2]] + xlab(""), box[[3]] + xlab(""), box[[4]] + xlab(""), labels=c("A", "B", "C", "D"), ncol = 2, nrow = 2, align = 'v', hjust=-1, vjust = 1.5, label_size=14)
  save_plot(filename = file.path(user_args$outdir,paste0(user_args$prefix, "ExtraStats.pdf")), plotExtraStats, ncol = 2, nrow = 2, base_aspect_ratio = 1 )
  
  print("All plots saved\n")
}

#remove empty plot created by running via command line
fn = file.path("~", "Rplots.pdf")
if (file.exists(fn)) file.remove(fn)

#stop connection to stdout
sink()
